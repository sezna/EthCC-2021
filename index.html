<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Sway by Fuel Labs</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section data-markdown>
          <textarea data-template>
            ## Sway: A Rust-based Smart Contract Language

            Alex Hansen

            Fuel Labs

            Sorbonne Room, 4:25pm

Note:
This talk will presume some level of elementary familiarity with both Solidity and Rust, but, if you have any questions, do feel free to ask.
This talk will also contain a lot of code examples and A/B comparisions, essentially amounting to a tutorial in Sway for those who know Solidity. 
I will do my best to impart my jovial personality on this lecture, hopefully influencing your impressions of our language.
My name is Alex, the main compiler engineer at Fuel.
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            # What is Sway?
            <aside class="notes">
              Sway was motivated by Solidity and Rust. We believe Rust made a lot of correct decisions in its implementation,
              and we want to combine that with the ergonomic first-class blockchain support that Solidity brings to the table. 

              Look at its adoption: it is used more than approaches that import libraries and APIs into existing general purpose langauges
              to accomplish the same task. Using a language designed for this domain is what people want.
            </aside>
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            <img src="https://rustacean.net/assets/rustacean-orig-noshadow.svg" width=200 alt="rust" style="margin-bottom: -50px" /> 
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
                <li>Syntax</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
                <li>Syntax</li>
                <li>Trait-based Shared Behavior</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
                <li>Syntax</li>
                <li>Trait-based Shared Behavior</li>
                <li>Packaged with tooling</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
                <li>Syntax</li>
                <li>Trait-based Shared Behavior</li>
                <li>Packaged with tooling</li>
                <li>Team organization</li>
              </ul>
            </section>
            <aside class="notes">
              So, we grabbed some philosophy from Rust, some philosophy from Solidity, and got to work. From Rust, we took 

              Also, ifs are expressions. yeah? yeah!
            </aside>
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            <h2><img src="https://docs.soliditylang.org/en/v0.8.6/_images/logo.svg" width=200px alt="solidity" style="filter: invert(70%);" /></h2>
            <section data-auto-animate>
              <ul>
                <li>Designed around smart contract development</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Designed around smart contract development</li>
                <li>Integrates contract storage as a language construct</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Designed around smart contract development</li>
                <li>Integrates contract storage as a language construct</li>
                <li>Allows for shareable contract interfaces</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Designed around smart contract development</li>
                <li>Integrates contract storage as a language construct</li>
                <li>Allows for shareable contract interfaces</li>
                <li>Feels like it was actually made for the task</li>
              </ul>
            </section>
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            <h2><img src="https://avatars.githubusercontent.com/u/55993183?s=200&v=4" width=200px alt="fuel labs" /> </h2>
            <section data-auto-animate>
              <ul>
                <aside class="notes">
                  Additionally, we ourselves had some independent priorities.
                </aside>
                <li>Be fast and efficient</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Be fast and efficient</li>
                <li>Be easily auditable</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Be fast and efficient</li>
                <li>Be easily auditable</li>
                <li>Maintain SemVer and backwards port security fixes</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Be fast and efficient</li>
                <li>Be easily auditable</li>
                <li>Maintain SemVer and backwards port security fixes</li>
                <li>Generally learn from angry tweets about both Solidity and Rust</li>
                <aside class="notes">
                  What does this actually mean in terms of developer experience?
                </aside>
              </ul>
            </section>
          </textarea>
        </section>
        <section>
            <img src="https://raw.githubusercontent.com/sezna/EthCC-2021/main/images/twitter_1.png" />
        </section>
        <section>
            <img src="https://raw.githubusercontent.com/sezna/EthCC-2021/main/images/twitter_2.png" />
        </section>
        <section>
            <img src="https://raw.githubusercontent.com/sezna/EthCC-2021/main/images/twitter_3.png" />
        </section>
        <section data-markdown>
          <textarea data-template>
            <img src="https://raw.githubusercontent.com/sezna/EthCC-2021/main/images/dank_meme_1.jpg" />
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            ## And, how does this work again?
            1. Swappable compiler back end
            1. From-scratch implementation, re-using lots of Rust and Solidity design decisions
            1. A full team of developers working on tooling in parallel with the compiler.
            <aside class="notes">
              The swappable back end allows for targeting different chains. We are starting with Ethereum.
              for point 2 -- we found that libraries or extensions of other general purpose languages tend
              to lack the domain specificity that smart contract development requires
              For point 3 -- we believe it invaluable that the tooling developers and the compiler developers are
              working in close communication. This is something that is not often seen with Solidity, and it has led
              to fracturing. Our formatter, testing, deployment, compiler, and more are all written by the same team of people.
            </aside>
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### State Variables


```solidity
pragma solidity &gt;=0.4.0 &lt;0.9.0;
contract SimpleStorage {
    uint storedData; // State variable
    // ...
}
```

Note:
Let's dive right in. Solidity begins its documentation by introducing us to some basic contract storage. 
This pragma is handled in our toml file, similarly to how Rust configures via Cargo.toml.


```solidity
pragma solidity &gt;=0.4.0 &lt;0.9.0;
contract SimpleStorage {
    uint storedData; // State variable
    // ...
}
```
```rust
contract;
let mut stored_data = 0;

fn contract_function() { 
  contract.stored_data += 1;
}
```

Note:
We have a few reasons behind this design decision. For one, remember that tweet? Have you ever prefixed a variable with something to denote that it is indeed a state variable?
We see no reason why that shouldn't be a language pattern, so, to access state variables, we use the `contract` keyword.
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Functions


```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity &gt;0.7.0 &lt;0.9.0;

contract SimpleAuction {
    function bid() public payable { // Function
        // ...
    }
}

// Helper function defined outside of a contract
function helper(uint x) pure returns (uint) {
    return x * 2;
}

```
Note:
A function in Solidity looks like this. Let's take a look at what this is doing -- we are creating an auction contract with some bid method that is payable. 
We also have a helper pure function which multiplies a number by 2.


```rust
contract;

abi SimpleAuction {
  fn bid();
}

impl SimpleAuction for Contract {
  fn bid() {
    ..
  }
}

fn helper(x: u64) -&gt; u64 {
  x * 2
}

```

Note:
Now, let's take a look at the equivalent Sway code.
There are three examples of functions here. Let's take a look at the function called `helper`. (point out: rust syntax, type annotation, return type, implicit return)

We have replaced the Solidity inheritence/constructor based system with a trait based system.
While in this code snippet, this results in a few more lines of boilerplate for Sway, in general, this is not the case. Less boilerplate and a more predictable system. 
The `abi` keyword denotes what is essentially a trait -- a type class for you Haskellers, an interface for you Java beans. This defines an interface that can be imported 
into other Sway programs to either implement contracts with the same interface, or, to interact with contracts. But we will get to that in a bit. For now, just know that the `abi` 
keyword defines a special kind of trait, typeclass, what-have-you, that can be implemented on contracts themselves.

Functions are pure by default.


```solidity
contract Purchase {
    address public seller;

    modifier onlySeller() { // Modifier
        require(
          msg.sender == seller,
          "Only seller can call this."
        );
        _;
    }

    // Modifier usage
    function abort() public view onlySeller { 
        // ...
    }
}
```

Note:
cover removal of modifiers, assert! macro instead of require


```rust
contract;

let seller: Address = Address(
  0xDEADBEEF...
);

abi Purchase {
  view fn abort_inner();
} 

impl Purchase for Contract {
  view fn abort() {
    assert_eq!(contract.caller_id, seller);
    abort()
  }
}
```

Note:
view functions, constant values, deploy-time values, macros, assert_eq, modifiers can be solved with 
function composition and have nothing to do with the blockchain therefore we didn't keep them
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Events


```solidity
contract SimpleAuction {
    // Event
    event HighestBidIncreased(address bidder, uint amount); 

    function bid() public payable {
        // ...
        // Triggering event
        emit HighestBidIncreased(msg.sender, msg.value); 
    }
}
```

Note:
Here's an event and event emission from Solidity.


```rust
contract;
use std::chain::Address;

struct HighestBidIncreased {
  bidder: Address,
  amount: u64
}

impl SimpleAuction for Contract {
  fn bid() {
    [ ... ]
    emit(HighestBidIncreased {
      contract.msg_sender, contract.amount
    });
  }
}
```

Note:
There's not really a reason events need to be events and not structs, so we just use structs for this. Emit is not a keyword but a generic function in the standard library.
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Errors


```solidity
error NotEnoughFunds(uint requested, uint available);

contract Token {
    mapping(address =&gt; uint) balances;
    function transfer(address to, uint amount) public {
        uint balance = balances[msg.sender];
        if (balance &lt; amount)
            revert NotEnoughFunds(amount, balance);
        balances[msg.sender] -= amount;
        balances[to] += amount;
        // ...
    }
}
```

Note:
Here's another cool thing solidity does -- reverts in your control flow. We want to keep that.


```rust
contract;
use std::chain::Address;

struct NotEnoughFunds { 
  requested: u64, 
  available: u64
}

impl Token for Contract {
  naughty fn transfer(to: Address, amount: u64) {
        if balance &lt; amount { 
          revert(NotEnoughFunds { requested: amount, available: contract.balances[msg.sender] });
        }
        contract.balances[msg.sender] -= amount;
        contract.balances[to] += amount;
        // ...
  }
}
```

Note:
note on naughty, mapping, revert is like panic! via Revertable trait which controls how it shows up in a revert
Should you want to revert, you don't need a return type since that aborts the control flow. However, you are perfectly free to also do this:


```rust
contract;
use std::chain::Address;

struct NotEnoughFunds { 
  requested: u64, 
  available: u64
}

impl Token for Contract {
  naughty fn transfer(to: Address, amount: u64) 
    -&gt; Result&lt;(), NotEnoughFunds&gt; {
        if balance &lt; amount { 
          return Err(NotEnoughFunds { 
           requested: amount,
           available: contract.balances[msg.sender] 
          });
        }
        contract.balances[msg.sender] -= amount;
        contract.balances[to] += amount;
        // ...
  }
}
```

Note:
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Structs and Enums
    
Note:
Show of hands -- who here knows what I mean when I say "product types" and "sum types"? Or "pi" and "sigma" types? Those are silly words. We want structs and enums, of course. Does anybody know what product and sum types we've seen already?



```rust <!--  data-line-numbers -->
struct NotEnoughFunds { 
  requested: u64, 
  available: u64
}

enum Result&lt;T, E&gt; {
  Ok: T,
  Err: E,
}
```

          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Types

Note:
Our type system is essentially the same as Rust's, with a few differences:



### Primitive Types
1. Unsigned Integers
1. Booleans
1. Static-length strings
1. 32-byte values
1. Single-byte values
1. The unit type

Note: 
We mainly just support the primitive types that Solidity cares about, and are common in smart contracts.


### Generics and Traits

```rust
contract;
trait Foo&lt;T, E&gt;
  where T: Bar + Baz,
        E: Quux {
      [ ... ]
  }
```

Note: 
We do fully support generic types and traits in the same way Rust does.
All of the solidity address, contract, and hash types are wrapper types around byte32 with their own APIs in the standard library.

Bytes and addresses can be declared with literal syntax.


```rust
let x: byte32 =
 0xAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAF; 

let y: byte = 0xAF;

let z: byte = 0b10101010;
```
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Speed round


#### Ifs are expressions
```rust
let civilian_time = if time.hours &gt; 12 {
    Time { 
      hours: time.hours - 12, 
      minutes: time.minutes 
    }
  } else {
    time
  };
```


#### Unchecked Arithmetic

```rust
arithmetic: wrapping {
   0xff_fff_fffu32 + 1 == 0
}
```

Note: we use the canonical names of the arithmetic types instead of the more vague "unchecked" term. Math will panic if it overflows by default. 


#### Sweet underscore syntax
```rust
arithmetic: wrapping {
   0xff_fff_fffu32 + 1 == 0
}
```

          </textarea>
        </section>
			</div>
		</div>

  <script> 
      document.querySelectorAll("code").forEach(elem => elem.classList.add('with-line-numbers'));
      document.querySelectorAll("code").forEach(elem => elem.setAttribute('data-line-numbers', true));

  </script>
		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
  <script>
/**
 * highlight.js Solidity syntax highlighting definition
 *
 * @see https://github.com/isagalaev/highlight.js
 *
 * :TODO:
 * - fixed point numbers
 * - `_` inside modifiers
 * - assembly block keywords
 *
 * @package: highlightjs-solidity
 * @author:  Sam Pospischil <sam@changegiving.com>
 * @since:   2016-07-01
 */

var module = module ? module : {};     // shim for browser use

function hljsDefineSolidity(hljs) {
    var SOL_KEYWORDS = {
        keyword:
            'var bool string ' +
            'int uint int8 uint8 int16 uint16 int24 uint24 int32 uint32 ' +
            'int40 uint40 int48 uint48 int56 uint56 int64 uint64 ' +
            'int72 uint72 int80 uint80 int88 uint88 int96 uint96 ' +
            'int104 uint104 int112 uint112 int120 uint120 int128 uint128 ' +
            'int136 uint136 int144 uint144 int152 uint152 int160 uint160 ' +
            'int168 uint168 int176 uint176 int184 uint184 int192 uint192 ' +
            'int200 uint200 int208 uint208 int216 uint216 int224 uint224 ' +
            'int232 uint232 int240 uint240 int248 uint248 int256 uint256 ' +
            'byte bytes bytes1 bytes2 bytes3 bytes4 bytes5 bytes6 bytes7 bytes8 ' +
            'bytes9 bytes10 bytes11 bytes12 bytes13 bytes14 bytes15 bytes16 ' +
            'bytes17 bytes18 bytes19 bytes20 bytes21 bytes22 bytes23 bytes24 ' +
            'bytes25 bytes26 bytes27 bytes28 bytes29 bytes30 bytes31 bytes32 ' +
            'enum struct mapping address ' +

            'new delete ' +
            'if else for while continue break return throw assert require revert ' +

            'function modifier event ' +
            'constant anonymous indexed ' +
            'storage memory ' +
            'external public internal pure view private returns ' +

            'import using ' +
            'contract interface library ' +
            'assembly',
        literal:
            'true false ' +
            'wei szabo finney ether ' +
            'second seconds minute minutes hour hours day days week weeks year years',
        built_in:
            'self ' +   // :NOTE: not a real keyword, but a convention used in storage manipulation libraries
            'this super selfdestruct ' +
            'now ' +
            'msg ' +
            'block ' +
            'tx ' +
            'sha3 sha256 ripemd160 erecover addmod mulmod ' +
            // :NOTE: not really toplevel, but advantageous to have highlighted as if reserved to
            //        avoid newcomers making mistakes due to accidental name collisions.
            'send call callcode delegatecall',
    };

    var SOL_NUMBER = {
        className: 'number',
        variants: [
            { begin: '\\b(0[bB][01]+)' },
            { begin: '\\b(0[oO][0-7]+)' },
            { begin: hljs.C_NUMBER_RE },
        ],
        relevance: 0,
    };

    var SOL_FUNC_PARAMS = {
        className: 'params',
        begin: /\(/, end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: SOL_KEYWORDS,
        contains: [
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            SOL_NUMBER,
        ],
    };

    var SOL_RESERVED_MEMBERS = {
        begin: /\.\s*/,  // match any property access up to start of prop
        end: /[^A-Za-z0-9$_\.]/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: {
            built_in: 'gas value send call callcode delegatecall balance length push',
        },
        relevance: 2,
    };

    function makeBuiltinProps(obj, props) {
        return {
            begin: obj + '\\.\\s*',
            end: /[^A-Za-z0-9$_\.]/,
            excludeBegin: false,
            excludeEnd: true,
            keywords: {
                built_in: obj + ' ' + props,
            },
            contains: [
                SOL_RESERVED_MEMBERS,
            ],
            relevance: 10,
        };
    }

    return {
        aliases: ['sol'],
        keywords: SOL_KEYWORDS,
        contains: [
            // basic literal definitions
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            SOL_NUMBER,
            { // functions
                className: 'function',
                beginKeywords: 'function modifier event', end: /[{;]/, excludeEnd: true,
                contains: [
                    hljs.inherit(hljs.TITLE_MODE, {
                        begin: /[A-Za-z$_][0-9A-Za-z$_]*/,
                        keywords: SOL_KEYWORDS,
                    }),
                    SOL_FUNC_PARAMS,
                ],
                illegal: /\[|%/,
            },
            // built-in members
            makeBuiltinProps('msg', 'data sender sig'),
            makeBuiltinProps('block', 'blockhash coinbase difficulty gaslimit number timestamp '),
            makeBuiltinProps('tx', 'gasprice origin'),
            SOL_RESERVED_MEMBERS,
            { // contracts & libraries & interfaces
                className: 'class',
                beginKeywords: 'contract interface library', end: /[{]/, excludeEnd: true,
                illegal: /[:"\[\]]/,
                contains: [
                    { beginKeywords: 'is' },
                    hljs.UNDERSCORE_TITLE_MODE,
                    SOL_FUNC_PARAMS,
                ],
            },
            { // imports
                beginKeywords: 'import', end: '[;$]',
                keywords: 'import * from as',
                contains: [
                    hljs.APOS_STRING_MODE,
                    hljs.QUOTE_STRING_MODE,
                ],
            },
        ],
        illegal: /#/,
    };
}

module.exports = function(hljs) {
    hljs.registerLanguage('solidity', hljsDefineSolidity);
};

module.exports.definer = hljsDefineSolidity;
  </script>
    <script type="text/javascript">
        window.hljs.registerLanguage('solidity', window.hljsDefineSolidity);
        window.hljs.highlightAll();
    </script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
