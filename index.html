<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Sway by Fuel Labs</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section data-markdown>
          <textarea data-template>
            ## Sway: A Rust-based Smart Contract Language

            Alex Hansen

            Fuel Labs

            Sorbonne Room, 4:25pm

Note:
This talk will presume some level of elementary familiarity with both Solidity and Rust, but, if you have any questions, do feel free to ask.
This talk will also contain a lot of code examples and A/B comparisions, essentially amounting to a tutorial in Sway for those who know Solidity. 
I will do my best to impart my jovial personality on this lecture, hopefully influencing your impressions of our language.
My name is Alex, the main compiler engineer at Fuel.
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            # What is Sway?
            <aside class="notes">
              Sway was motivated by Solidity and Rust. We believe Rust made a lot of correct decisions in its implementation,
              and we want to combine that with the ergonomic first-class blockchain support that Solidity brings to the table. 

              Look at its adoption: it is used more than approaches that import libraries and APIs into existing general purpose langauges
              to accomplish the same task. Using a language designed for this domain is what people want.
            </aside>
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            <img src="https://rustacean.net/assets/rustacean-orig-noshadow.svg" width=200 alt="rust" style="margin-bottom: -50px" /> 
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
                <li>Syntax</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
                <li>Syntax</li>
                <li>Trait-based Shared Behavior</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
                <li>Syntax</li>
                <li>Trait-based Shared Behavior</li>
                <li>Packaged with tooling</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Statically Typed</li>
                <li>Verbose and friendly compiler</li>
                <li>Syntax</li>
                <li>Trait-based Shared Behavior</li>
                <li>Packaged with tooling</li>
                <li>Team organization</li>
              </ul>
            </section>
            <aside class="notes">
              So, we grabbed some philosophy from Rust, some philosophy from Solidity, and got to work. From Rust, we took 

              Also, ifs are expressions. yeah? yeah!
            </aside>
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            <h2><img src="https://docs.soliditylang.org/en/v0.8.6/_images/logo.svg" width=200px alt="solidity" style="filter: invert(70%);" /></h2>
            <section data-auto-animate>
              <ul>
                <li>Designed around smart contract development</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Designed around smart contract development</li>
                <li>Integrates contract storage as a language construct</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Designed around smart contract development</li>
                <li>Integrates contract storage as a language construct</li>
                <li>Allows for shareable contract interfaces</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Designed around smart contract development</li>
                <li>Integrates contract storage as a language construct</li>
                <li>Allows for shareable contract interfaces</li>
                <li>Feels like it was actually made for the task</li>
              </ul>
            </section>
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            <h2><img src="https://avatars.githubusercontent.com/u/55993183?s=200&v=4" width=200px alt="fuel labs" /> </h2>
            <section data-auto-animate>
              <ul>
                <aside class="notes">
                  Additionally, we ourselves had some independent priorities.
                </aside>
                <li>Be fast and efficient</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Be fast and efficient</li>
                <li>Be easily auditable</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Be fast and efficient</li>
                <li>Be easily auditable</li>
                <li>Maintain SemVer and backwards port security fixes</li>
              </ul>
            </section>
            <section data-auto-animate>
              <ul>
                <li>Be fast and efficient</li>
                <li>Be easily auditable</li>
                <li>Maintain SemVer and backwards port security fixes</li>
                <li>Generally learn from angry tweets about both Solidity and Rust</li>
                <aside class="notes">
                  What does this actually mean in terms of developer experience?
                </aside>
              </ul>
            </section>
          </textarea>
        </section>
        <section>
            <img src="https://raw.githubusercontent.com/sezna/EthCC-2021/main/images/twitter_1.png" />
        </section>
        <section>
            <img src="https://raw.githubusercontent.com/sezna/EthCC-2021/main/images/twitter_2.png" />
        </section>
        <section>
            <img src="https://raw.githubusercontent.com/sezna/EthCC-2021/main/images/twitter_3.png" />
        </section>
        <section data-markdown>
          <textarea data-template>
            <img src="https://raw.githubusercontent.com/sezna/EthCC-2021/main/images/dank_meme_1.jpg" />
          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            ## And, how does this work again?
            1. Swappable compiler back end
            1. From-scratch implementation, re-using lots of Rust and Solidity design decisions
            1. A full team of developers working on tooling in parallel with the compiler.
            <aside class="notes">
              The swappable back end allows for targeting different chains. We are starting with Ethereum.
              for point 2 -- we found that libraries or extensions of other general purpose languages tend
              to lack the domain specificity that smart contract development requires
              For point 3 -- we believe it invaluable that the tooling developers and the compiler developers are
              working in close communication. This is something that is not often seen with Solidity, and it has led
              to fracturing. Our formatter, testing, deployment, compiler, and more are all written by the same team of people.
            </aside>
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### State Variables


```solidity
pragma solidity &gt;=0.4.0 &lt;0.9.0;
contract SimpleStorage {
    uint storedData; // State variable
    // ...
}
```

Note:
Let's dive right in. Solidity begins its documentation by introducing us to some basic contract storage. 
This pragma is handled in our toml file, similarly to how Rust configures via Cargo.toml.


```solidity
pragma solidity &gt;=0.4.0 &lt;0.9.0;
contract SimpleStorage {
    uint storedData; // State variable
    // ...
}
```
```rust
contract;
let mut stored_data = 0;

fn contract_function() { 
  contract.stored_data += 1;
}
```

Note:
We have a few reasons behind this design decision. For one, remember that tweet? Have you ever prefixed a variable with something to denote that it is indeed a state variable?
We see no reason why that shouldn't be a language pattern, so, to access state variables, we use the `contract` keyword.
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Functions


```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity &gt;0.7.0 &lt;0.9.0;

contract SimpleAuction {
    function bid() public payable { // Function
        // ...
    }
}

// Helper function defined outside of a contract
function helper(uint x) pure returns (uint) {
    return x * 2;
}

```
Note:
A function in Solidity looks like this. Let's take a look at what this is doing -- we are creating an auction contract with some bid method that is payable. 
We also have a helper pure function which multiplies a number by 2.


```rust
contract;

abi SimpleAuction {
  fn bid();
}

impl SimpleAuction for Contract {
  fn bid() {
    ..
  }
}

fn helper(x: u64) -&gt; u64 {
  x * 2
}

```

Note:
Now, let's take a look at the equivalent Sway code.
There are three examples of functions here. Let's take a look at the function called `helper`. (point out: rust syntax, type annotation, return type, implicit return)

We have replaced the Solidity inheritence/constructor based system with a trait based system.
While in this code snippet, this results in a few more lines of boilerplate for Sway, in general, this is not the case. Less boilerplate and a more predictable system. 
The `abi` keyword denotes what is essentially a trait -- a type class for you Haskellers, an interface for you Java beans. This defines an interface that can be imported 
into other Sway programs to either implement contracts with the same interface, or, to interact with contracts. But we will get to that in a bit. For now, just know that the `abi` 
keyword defines a special kind of trait, typeclass, what-have-you, that can be implemented on contracts themselves.

Functions are pure by default.


```solidity
contract Purchase {
    address public seller;

    modifier onlySeller() { // Modifier
        require(
          msg.sender == seller,
          "Only seller can call this."
        );
        _;
    }

    // Modifier usage
    function abort() public view onlySeller { 
        // ...
    }
}
```

Note:
cover removal of modifiers, assert! macro instead of require


```rust
contract;

let seller: Address = Address(
  0xDEADBEEF...
);

abi Purchase {
  view fn abort_inner();
} 

impl Purchase for Contract {
  view fn abort() {
    assert_eq!(contract.caller_id, seller);
    abort()
  }
}
```

Note:
view functions, constant values, deploy-time values, macros, assert_eq, modifiers can be solved with 
function composition and have nothing to do with the blockchain therefore we didn't keep them
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Events


```solidity
contract SimpleAuction {
    // Event
    event HighestBidIncreased(address bidder, uint amount); 

    function bid() public payable {
        // ...
        // Triggering event
        emit HighestBidIncreased(msg.sender, msg.value); 
    }
}
```

Note:
Here's an event and event emission from Solidity.


```rust
contract;
use std::chain::Address;

struct HighestBidIncreased {
  bidder: Address,
  amount: u64
}

impl SimpleAuction for Contract {
  fn bid() {
    [ ... ]
    emit(HighestBidIncreased {
      contract.msg_sender, contract.amount
    });
  }
}
```

Note:
There's not really a reason events need to be events and not structs, so we just use structs for this. Emit is not a keyword but a generic function in the standard library.
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Errors


```solidity
error NotEnoughFunds(uint requested, uint available);

contract Token {
    mapping(address =&gt; uint) balances;
    function transfer(address to, uint amount) public {
        uint balance = balances[msg.sender];
        if (balance &lt; amount)
            revert NotEnoughFunds(amount, balance);
        balances[msg.sender] -= amount;
        balances[to] += amount;
        // ...
    }
}
```

Note:
Here's another cool thing solidity does -- reverts in your control flow. We want to keep that.


```rust
contract;
use std::chain::Address;

struct NotEnoughFunds { 
  requested: u64, 
  available: u64
}

impl Token for Contract {
  naughty fn transfer(to: Address, amount: u64) {
        if balance &lt; amount { 
          revert(NotEnoughFunds { requested: amount, available: contract.balances[msg.sender] });
        }
        contract.balances[msg.sender] -= amount;
        contract.balances[to] += amount;
        // ...
  }
}
```

Note:
note on naughty, mapping, revert is like panic! via Revertable trait which controls how it shows up in a revert
Should you want to revert, you don't need a return type since that aborts the control flow. However, you are perfectly free to also do this:


```rust
contract;
use std::chain::Address;

struct NotEnoughFunds { 
  requested: u64, 
  available: u64
}

impl Token for Contract {
  naughty fn transfer(to: Address, amount: u64) 
    -&gt; Result&lt;(), NotEnoughFunds&gt; {
        if balance &lt; amount { 
          return Err(NotEnoughFunds { 
           requested: amount,
           available: contract.balances[msg.sender] 
          });
        }
        contract.balances[msg.sender] -= amount;
        contract.balances[to] += amount;
        // ...
  }
}
```

Note:
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Structs and Enums
    
Note:
Show of hands -- who here knows what I mean when I say "product types" and "sum types"? Or "pi" and "sigma" types? Those are silly words. We want structs and enums, of course. Does anybody know what product and sum types we've seen already?



```rust <!--  data-line-numbers -->
struct NotEnoughFunds { 
  requested: u64, 
  available: u64
}

enum Result&lt;T, E&gt; {
  Ok: T,
  Err: E,
}
```

          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Types

Note:
Our type system is essentially the same as Rust's, with a few differences:



### Primitive Types
1. Unsigned Integers
1. Booleans
1. Static-length strings
1. 32-byte values
1. Single-byte values
1. The unit type

Note: 
We mainly just support the primitive types that Solidity cares about, and are common in smart contracts.


### Generics and Traits

```rust
contract;
trait Foo&lt;T, E&gt;
  where T: Bar + Baz,
        E: Quux {
      [ ... ]
  }
```

Note: 
We do fully support generic types and traits in the same way Rust does.
All of the solidity address, contract, and hash types are wrapper types around byte32 with their own APIs in the standard library.

Bytes and addresses can be declared with literal syntax.


```rust
let x: byte32 =
 0xAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAFAF; 

let y: byte = 0xAF;

let z: byte = 0b10101010;
```
          </textarea>
        </section>
        <section data-markdown data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ### Speed round


#### Ifs are expressions
```rust
let civilian_time = if time.hours &gt; 12 {
    Time { 
      hours: time.hours - 12, 
      minutes: time.minutes 
    }
  } else {
    time
  };
```


#### Unchecked Arithmetic

```rust
arithmetic: wrapping {
   0xff_fff_fffu32 + 1 == 0
}
```

Note: we use the canonical names of the arithmetic types instead of the more vague "unchecked" term. Math will panic if it overflows by default. 


#### Sweet underscore syntax
```rust
arithmetic: wrapping {
   0xff_fff_fffu32 + 1 == 0
}
```

          </textarea>
        </section>
			</div>
		</div>

  <script> 
      document.querySelectorAll("code").forEach(elem => elem.classList.add('with-line-numbers'));
      document.querySelectorAll("code").forEach(elem => elem.setAttribute('data-line-numbers', true));

  </script>
		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
    <script type="text/javascript" src="/plugin/solidity.js"></script>
    <script type="text/javascript">
        window.hljs.registerLanguage('solidity', window.hljsDefineSolidity);
        window.hljs.highlightAll();
    </script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
